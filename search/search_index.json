{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Phootwork! Many PHP functions are simply wrappers around the native C counterparts, and they do their great work since the earliest php versions. The time passed, the versions increased and PHP 5 and PHP 7 arrived, with their brand new object oriented heart. Anyway, those functions are still there and new PHP versions don't offer alternatives. Phootwork is a collection of php libraries which fill these gaps in the php language and provides consistent object oriented solutions where the language natively offers only functions. The phootwork package includes: collection a library to model several flavours of collections file an object oriented library to manipulate filesystems elements ( stream compatible ) json a json library, with clean syntax and proper error handling lang a library to manipulate arrays and strings in an object oriented way tokenizer an easy to use tokenizer library for PHP code xml an object oriented xml utility library Installation We use composer as dependency manager and distribution system. To install the library run: composer require phootwork/phootwork Each single package can be installed separately. I.e. if you want to include in your project the collection library only: composer require phootwork/collection Note The single library packages does not ship with tests and --dev dependencies. If you want to run the test suite or contribute to the library, you have to install the whole phootwork/phootwork package. A Little Taste The following examples show what you can find in this library. You can discover much, much more by reading the documentation and the api. A Little Taste of lang Library ( phootwork\\lang\\Text class); <?php declare(strict_types=1); /** * Example describing how to manipulate a string via the Text class * and its nice fluent api. */ use phootwork\\lang\\Text; $text = new Text('a beautiful string'); // Remove the substring 'a ' and capitalize. Note: Text objects are *immutable*, // so you should assign the result to a variable $text = $text->slice(2)->toCapitalCase(); // 'Beautiful string' // Capitalize each word and add an 's' character at the end of the string $text = $text->toCapitalCaseWords()->append('s'); // 'Beautiful Strings' // Calculate the length of the string $length = $text->length(); // 17 // Check if the string ends with the 'ngs' substring $text->endsWith('ngs'); // true A Little Taste of collection Library ( phootwork\\collection\\Stack class) <?php declare(strict_types=1); /** * Example describing how to manipulate a Stack collection (Last In First Out) * via the Stack class */ use phootwork\\collection\\Stack; $stack = new Stack(['Obiwan', 'Luke', 'Yoda', 'Leila']); // Sort the stack $stack = $stack->sort(); // ['Leila', 'Luke', 'Obiwan', 'Yoda'] // Check if the collection contains any elements $stack->isEmpty(); // false // How many elements? $stack->size(); // 4 // Push an elememt $stack->push('Chewbecca'); // How many elements now? $stack->size(); // 5 // Peek the head element (return the head element, without removing it) $stack->peek(); // 'Chewbecca' $stack->size(); // 5 // Pop the head element $stack->pop(); // 'Chewbecca' $stack->size(); // 4: pop() removes the popped element Any issue? Found a typo?","title":"Home"},{"location":"#welcome-to-phootwork","text":"Many PHP functions are simply wrappers around the native C counterparts, and they do their great work since the earliest php versions. The time passed, the versions increased and PHP 5 and PHP 7 arrived, with their brand new object oriented heart. Anyway, those functions are still there and new PHP versions don't offer alternatives. Phootwork is a collection of php libraries which fill these gaps in the php language and provides consistent object oriented solutions where the language natively offers only functions. The phootwork package includes: collection a library to model several flavours of collections file an object oriented library to manipulate filesystems elements ( stream compatible ) json a json library, with clean syntax and proper error handling lang a library to manipulate arrays and strings in an object oriented way tokenizer an easy to use tokenizer library for PHP code xml an object oriented xml utility library","title":"Welcome to Phootwork!"},{"location":"#installation","text":"We use composer as dependency manager and distribution system. To install the library run: composer require phootwork/phootwork Each single package can be installed separately. I.e. if you want to include in your project the collection library only: composer require phootwork/collection Note The single library packages does not ship with tests and --dev dependencies. If you want to run the test suite or contribute to the library, you have to install the whole phootwork/phootwork package.","title":"Installation"},{"location":"#a-little-taste","text":"The following examples show what you can find in this library. You can discover much, much more by reading the documentation and the api.","title":"A Little Taste"},{"location":"#a-little-taste-of-lang-library-phootworklangtext-class","text":"<?php declare(strict_types=1); /** * Example describing how to manipulate a string via the Text class * and its nice fluent api. */ use phootwork\\lang\\Text; $text = new Text('a beautiful string'); // Remove the substring 'a ' and capitalize. Note: Text objects are *immutable*, // so you should assign the result to a variable $text = $text->slice(2)->toCapitalCase(); // 'Beautiful string' // Capitalize each word and add an 's' character at the end of the string $text = $text->toCapitalCaseWords()->append('s'); // 'Beautiful Strings' // Calculate the length of the string $length = $text->length(); // 17 // Check if the string ends with the 'ngs' substring $text->endsWith('ngs'); // true","title":"A Little Taste of lang Library (phootwork\\lang\\Text class);"},{"location":"#a-little-taste-of-collection-library-phootworkcollectionstack-class","text":"<?php declare(strict_types=1); /** * Example describing how to manipulate a Stack collection (Last In First Out) * via the Stack class */ use phootwork\\collection\\Stack; $stack = new Stack(['Obiwan', 'Luke', 'Yoda', 'Leila']); // Sort the stack $stack = $stack->sort(); // ['Leila', 'Luke', 'Obiwan', 'Yoda'] // Check if the collection contains any elements $stack->isEmpty(); // false // How many elements? $stack->size(); // 4 // Push an elememt $stack->push('Chewbecca'); // How many elements now? $stack->size(); // 5 // Peek the head element (return the head element, without removing it) $stack->peek(); // 'Chewbecca' $stack->size(); // 5 // Pop the head element $stack->pop(); // 'Chewbecca' $stack->size(); // 4: pop() removes the popped element Any issue? Found a typo?","title":"A Little Taste of collection Library (phootwork\\collection\\Stack class)"},{"location":"about/","text":"About Phootwork is created by gossi and maintained by himself and other contributors . The name Phootwork The name Phootwork (or Footwork) relates to one of the three main parts in breakdancing. Footwork rsp. downrocks is all dancing that happens on the ground. Similarly phootwork levels the ground for php applications. On Github Github organization: https://github.com/phootwork Github repository: https://github.com/phootwork/phootwork Versioning The versions of each package follow the rules below: Version 0. * The API is still in development; breaking changes can happen. Version 1. * For PHP versions >= 5.6 . Version 2. * For PHP versions >= 7.2 . Release notes Please, see Github releses","title":"About us"},{"location":"about/#about","text":"Phootwork is created by gossi and maintained by himself and other contributors .","title":"About"},{"location":"about/#the-name-phootwork","text":"The name Phootwork (or Footwork) relates to one of the three main parts in breakdancing. Footwork rsp. downrocks is all dancing that happens on the ground. Similarly phootwork levels the ground for php applications.","title":"The name Phootwork"},{"location":"about/#on-github","text":"Github organization: https://github.com/phootwork Github repository: https://github.com/phootwork/phootwork","title":"On Github"},{"location":"about/#versioning","text":"The versions of each package follow the rules below: Version 0. * The API is still in development; breaking changes can happen. Version 1. * For PHP versions >= 5.6 . Version 2. * For PHP versions >= 7.2 .","title":"Versioning"},{"location":"about/#release-notes","text":"Please, see Github releses","title":"Release notes"},{"location":"collection/","text":"Phoootwork collection Phootwork collection is a library inspired by java java.util.Collection , which provides some collections for PHP. These collections are available: Lists: ArrayList - provides a List Set - provides a Set (only unique elements) Stack - provides a Stack (FILO - first in last out) Queue - provides a Queue (FIFO - first in first out) Maps: Map - provides a Map All classes contain phpdoc, so your lovely IDE will provide content assist on all the methods. Installation Installation via composer: composer require phootwork/collection Functional Flavour Some method of the collections accepts a callback (usually a closure) as parameter; the passed function receives an element of the collection as parameter, i.e.: <?php declare(strict_types=1); $collection->someMethod(function(ElementType $element) { // some element manipulation }); You can also pass a value to the function, as an additional parameter and you'll find it as the second parameter of your function: <?php declare(strict_types=1); $collection->someMethod('a value', function(ElementType $element, $query) { // $query contains 'a value' string return $element->getSomething() === $query; }); Note Be careful: the parameters order is mandatory. See other examples along this document. ArrayList An ArrayList is a collection of data that can have same or different types and can be objects, too. Each element of the ArrayList collection has an index, similar to the normal array. When it's important for you to access the index (sometimes called position) of the elements into the collection, then ArrayList is the right choice for you. You can create an ArrayList collection by passing an array or an Iterator object to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); Now you're ready to manipulate your collection: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); $fruits->size(); // (int) 3 $fruits->isEmpty(); // (bool) false $fruits->contains('pear'); // (bool) true // Much more into the api documentation Addition You can add one or more elements to the ArrayList via the add() method: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); $fruits->add('banana'); $fruits->add('apricot', 'watermelon', 'lemon'); $fruits->toArray(); // ['apple', 'pear', 'peach', 'banana', 'apricot', 'watermelon', 'lemon'] As you can see in the example above, add method appends an element at the end of the collection. If you want to define the position of the added element you can use the insert() method; remember that the position starts from 0 (exactly as the index of an array): <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); $fruits->insert('banana', 1); $fruits->toArray(); // ['apple', 'banana', 'pear', 'peach'] The insertion of an element, at a given position, moves the next elements of one position. Warning If your ArrayList models an associative array (the indexes are strings) the insertion will overwrite the element at the given position. See the example below: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['fruit1' => 'apple', 'fruit2' => 'pear', 'fruit3' => 'peach']); $fruits->insert('banana', 'fruit1'); $fruits->toArray(); // ['fruit1' => 'banana', 'fruit2' => 'pear', 'fruit3' => 'peach'] A collection can contain any type of elements, i.e. arrays: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); $fruits->add('pineapple', ['kiwi', 'lychee'], 'dorian'); $fruits->toArray(); // ['apple', 'pear', 'peach', 'pineapple', ['kiwi', 'lychee'], 'dorian'] Map Applies the callback to the elements of a collection and returns an ArrayList object containing the result of the manipulation. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList([2, 3, 4]); $pow2 = $list->map(function (int $element): int { return $element * $element; }); print_r($pow2); // [4, 9, 16] Each Iteration with a callback function without returning anything. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList(range(1, 10)); $list->each(function(int $elem): void { // do something with $elem }); Reduce Iteratively reduce a collection to a single value using a callback function. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList(range(1, 10)); $sum = $list->reduce(function(int $a, int $b) { return $a + $b; }); echo $sum; // 55 Filter Filters elements of a collection using a callback function. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList([1, 2, 3, 4, 5, 6]); $odd = $list->filter(function (int $item): int { return $item & 1; }); print_r($odd); // [1, 3, 5] Search for Existence To search your collection pass in a function that takes an element as first item. If you pass a parameter to the search() function, this will be the second parameter to your passed function (useful if you don't want to use an anonymous function every time). <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList(range(1, 10)); $found = $list->search(function (int $elem): bool { return $elem === 4; }); // use a function that takes the query as second parameter // $query will have the value 4 as you've just passed in $found = $list->search(4, function (int $elem, int $query): bool { return $elem === $query; }); Find an Element While search() only tells you some element is present, if you want to return this element use the find() rsp. findAll() method. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'banana', 'pine', 'banana', 'ananas']); $pine = $fruits->find(function (string $elem): bool { return $elem === 'pine'; }); $bananas = $fruits->findAll(function(string $elem): bool { return $elem === 'banana'; }); Find an Index If you are interested in the index of a search, you can use findIndex() . There is also findLastIndex() which searches the list from back to front. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'banana', 'pine', 'banana', 'ananas']); $index = $fruits->findIndex(function (string $elem): bool { return $elem == 'banana'; }); echo $index; // 1 $lastIndex = $fruits->findLastIndex(function (string $elem): bool { return $elem == 'banana'; }); echo $lastIndex; // 3 Reversing You can swap the order of your elements with reverse() . <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList([5, 2, 8, 3, 9, 4, 6, 1, 7, 10]); $reversed = $list->reverse(); print_r($reversed); // [10, 7, 1, 6, 4, 9, 3, 8, 2, 5] Simple Sorting There is built in support for running sort() : <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $unsorted = new ArrayList([5, 2, 8, 3, 9, 4, 6, 1, 7, 10]); $sorted = $unsorted->sort(); print_r($sorted); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Bring your own Comparison Of course you can use your own comparison to sort a list. In the example below you can see a function in action. The returned value must be an integer: 0 if the first and the second values are equal, -1 if the first is minor of the second, 1 if the first is major of the second. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $unsorted = new ArrayList([5, 2, 8, 3, 9, 4, 6, 1, 7, 10]); $cmp = function (int $a, int $b): int { if ($a == $b) { return 0; } return ($a < $b) ? -1 : 1; }; $sorted = $unsorted->sort($cmp); print_r($sorted); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Or you can bring in any Comparator . So good, there is a ComparableComparator provided by phootwork/lang we can use. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; use phootwork\\lang\\ComparableComparator; $unsorted = new ArrayList(['x', 'c', 'a', 't', 'm']); $sorted = $unsorted->sort(new ComparableComparator()); print_r($sorted); // ['a', 'c', 'm', 't', 'x'] Remove You can remove one or more elements from a collection, via the remove() method: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'banana', 'pine', 'banana', 'ananas']); $fruits->remove('banana'); $fruits->remove('banana', 'ananas', 'pine'); $fruits->toArray(); // ['apple'] More Methods You can find more ArrayList methods into the api documentation . Set The Set collection is composed by unique elements. It shares much methods with ArrayList except those which manipulate indexes. When you use a Set collection you really don't care about indexes. As usual, you can create a Set collection by passing an array or an Iterator object to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\Set; $fruits = new Set(['apple', 'pear', 'peach']); Since the collection is composed by unique elements, any duplicates are ignored: <?php declare(strict_types=1); use phootwork\\collection\\Set; $fruits = new Set(['apple', 'pear', 'peach', 'pear', 'banana', 'apple']); $fruits->toArray(); // ['apple', 'pear', 'peach', 'banana'] Addition You can add one or more elements to the Set via the add() method: <?php declare(strict_types=1); use phootwork\\collection\\Set; $fruits = new Set(['apple', 'pear', 'peach']); $fruits->add('banana'); $fruits->add('pineapple', ['kiwi', 'lychee'], 'dorian'); $fruits->toArray(); // ['apple', 'pear', 'peach', 'pineapple', ['kiwi', 'lychee'], 'dorian'] // Since the Set elements are unique, the instruction below doesn't modify the collection $fruits->add('apple', 'peach'); $fruits->toArray(); // ['apple', 'pear', 'peach', 'pineapple', ['kiwi', 'lychee'], 'dorian'] Note Set doesn't have the insert() method. More Methods Many Set methods are shared with other collections: please see the api documentation and the examples above, in ArrayList section of this document. Map A Map is a collection of key-value pairs, where the value can be any type you want, objects included. You can think about Map as an associative array with super-powers. As usual, you can instantiate a new Map object by passing an associative array or an Iterator object to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(['1 wheel' => 'unicycle', '2 wheels' => 'scooter', '4 wheels' => 'car']); Additions You can add one element to a Map via the set() method, which requires the key as first argument and the value to add as second argument: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(['1 wheel' => 'unicycle', '2 wheels' => 'scooter', '4 wheels' => 'car']); $vehicles->set('3 wheels', 'sidecar'); You can add more elements via the setAll() method. It expects an associative array or an Iterator of elements to add: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(); $coll = [ '1 wheel' => 'unicycle', '2 wheels' => 'scooter', '3 wheels' => 'sidecar', '4 wheels' => 'car' ]; $vehicles->setAll($coll); Getting the Elements You can get an element of the collection via the get() method: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(['1 wheel' => 'unicycle', '2 wheels' => 'scooter', '4 wheels' => 'car']); $vehicles->get('4 wheels'); // return 'car' $vehicles->get('6 wheels'); // not found: return null You can also get the key of an element by passing it to the getKey() method: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(['1 wheel' => 'unicycle', '2 wheels' => 'scooter', '4 wheels' => 'car']); $vehicles->getKey('scooter'); // return '2 wheels' More Methods You can find all the other Map methods in the documentation api . Stack A Stack is a FILO (First In Last Out) collection. As usual you can create a Stack by passing an array, or an Iterator , to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\Stack; $fruits = new Stack(['apple', 'pear', 'peach']); Note When you deal with Stack, the order is important: the constructor pushes the elements to end of the passed array, so when you pop an element it results in the last of the given array. Additions You can add one or more elements to the Stack via the push() method: <?php declare(strict_types=1); use phootwork\\collection\\Stack; $fruits = new Stack(['apple', 'pear', 'peach']); $fruits->push('lemon'); $fruits->toArray(); //['apple', 'pear', 'peach', 'lemon'] $fruits->push('pine', 'banana', 'ananas'); $fruits->toArray(); //['apple', 'pear', 'peach', 'lemon', 'pine', 'banana', 'ananas'] Peek an Element The method peek() returns the last inserted element of the collection but it doesn't remove it: <?php declare(strict_types=1); use phootwork\\collection\\Stack; $fruits = new Stack(['apple', 'pear', 'peach', 'pine']); $fruits->size(); // 4 $fruits->peek(); // return 'pine' $fruits->size(); // still 4 Pop an Element Popping an element from a Stack means to retrieve the last inserted element and remove it from the collection: <?php declare(strict_types=1); use phootwork\\collection\\Stack; $fruits = new Stack(['apple', 'pear', 'peach', 'pine']); $fruits->size(); // 4 $fruits->pop(); // return 'pine' $fruits->size(); // 4 $fruits->toArray(); // ['apple', 'pear', 'peach'] More Methods You can find all the other Stack methods in the documentation api . Queue A Queue is a FIFO (First In First Out) collection. As usual, you can create a Queue by passing an array, or an Iterator , to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\Queue; $fruits = new Queue(['apple', 'pear', 'peach']); Note As for the Stack collection, when you deal with Queue, the order is important: the constructor enqueues the elements, so when you poll an element it results in the first of the given array. Additions You can add one or more elements to the Queue via the enqueue() method: <?php declare(strict_types=1); use phootwork\\collection\\Queue; $fruits = new Queue(['apple', 'pear', 'peach']); $fruits->enqueue('lemon'); $fruits->toArray(); //['lemon', 'apple', 'pear', 'peach'] Peek an Element The peek() method returns the first inserted element of the collection but it doesn't remove it: <?php declare(strict_types=1); use phootwork\\collection\\Queue; $fruits = new Queue(['apple', 'pear', 'peach', 'pine']); $fruits->size(); // 4 $fruits->peek(); // return 'apple' $fruits->size(); // still 4 Poll an Element Polling an element from a Queue means to retrieve the first inserted element from the collection and remove it: <?php declare(strict_types=1); use phootwork\\collection\\Queue; $fruits = new Queue(['apple', 'pear', 'peach', 'pine']); $fruits->size(); // 4 $fruits->poll(); // return 'apple' $fruits->size(); // 3 $fruits->toArray(); // ['pear', 'peach', 'pine'] More Methods You can find all the other Queue methods in the documentation api .","title":"Collection"},{"location":"collection/#phoootwork-collection","text":"Phootwork collection is a library inspired by java java.util.Collection , which provides some collections for PHP. These collections are available: Lists: ArrayList - provides a List Set - provides a Set (only unique elements) Stack - provides a Stack (FILO - first in last out) Queue - provides a Queue (FIFO - first in first out) Maps: Map - provides a Map All classes contain phpdoc, so your lovely IDE will provide content assist on all the methods.","title":"Phoootwork collection"},{"location":"collection/#installation","text":"Installation via composer: composer require phootwork/collection","title":"Installation"},{"location":"collection/#functional-flavour","text":"Some method of the collections accepts a callback (usually a closure) as parameter; the passed function receives an element of the collection as parameter, i.e.: <?php declare(strict_types=1); $collection->someMethod(function(ElementType $element) { // some element manipulation }); You can also pass a value to the function, as an additional parameter and you'll find it as the second parameter of your function: <?php declare(strict_types=1); $collection->someMethod('a value', function(ElementType $element, $query) { // $query contains 'a value' string return $element->getSomething() === $query; }); Note Be careful: the parameters order is mandatory. See other examples along this document.","title":"Functional Flavour"},{"location":"collection/#arraylist","text":"An ArrayList is a collection of data that can have same or different types and can be objects, too. Each element of the ArrayList collection has an index, similar to the normal array. When it's important for you to access the index (sometimes called position) of the elements into the collection, then ArrayList is the right choice for you. You can create an ArrayList collection by passing an array or an Iterator object to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); Now you're ready to manipulate your collection: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); $fruits->size(); // (int) 3 $fruits->isEmpty(); // (bool) false $fruits->contains('pear'); // (bool) true // Much more into the api documentation","title":"ArrayList"},{"location":"collection/#addition","text":"You can add one or more elements to the ArrayList via the add() method: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); $fruits->add('banana'); $fruits->add('apricot', 'watermelon', 'lemon'); $fruits->toArray(); // ['apple', 'pear', 'peach', 'banana', 'apricot', 'watermelon', 'lemon'] As you can see in the example above, add method appends an element at the end of the collection. If you want to define the position of the added element you can use the insert() method; remember that the position starts from 0 (exactly as the index of an array): <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); $fruits->insert('banana', 1); $fruits->toArray(); // ['apple', 'banana', 'pear', 'peach'] The insertion of an element, at a given position, moves the next elements of one position. Warning If your ArrayList models an associative array (the indexes are strings) the insertion will overwrite the element at the given position. See the example below: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['fruit1' => 'apple', 'fruit2' => 'pear', 'fruit3' => 'peach']); $fruits->insert('banana', 'fruit1'); $fruits->toArray(); // ['fruit1' => 'banana', 'fruit2' => 'pear', 'fruit3' => 'peach'] A collection can contain any type of elements, i.e. arrays: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'pear', 'peach']); $fruits->add('pineapple', ['kiwi', 'lychee'], 'dorian'); $fruits->toArray(); // ['apple', 'pear', 'peach', 'pineapple', ['kiwi', 'lychee'], 'dorian']","title":"Addition"},{"location":"collection/#map","text":"Applies the callback to the elements of a collection and returns an ArrayList object containing the result of the manipulation. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList([2, 3, 4]); $pow2 = $list->map(function (int $element): int { return $element * $element; }); print_r($pow2); // [4, 9, 16]","title":"Map"},{"location":"collection/#each","text":"Iteration with a callback function without returning anything. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList(range(1, 10)); $list->each(function(int $elem): void { // do something with $elem });","title":"Each"},{"location":"collection/#reduce","text":"Iteratively reduce a collection to a single value using a callback function. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList(range(1, 10)); $sum = $list->reduce(function(int $a, int $b) { return $a + $b; }); echo $sum; // 55","title":"Reduce"},{"location":"collection/#filter","text":"Filters elements of a collection using a callback function. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList([1, 2, 3, 4, 5, 6]); $odd = $list->filter(function (int $item): int { return $item & 1; }); print_r($odd); // [1, 3, 5]","title":"Filter"},{"location":"collection/#search-for-existence","text":"To search your collection pass in a function that takes an element as first item. If you pass a parameter to the search() function, this will be the second parameter to your passed function (useful if you don't want to use an anonymous function every time). <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList(range(1, 10)); $found = $list->search(function (int $elem): bool { return $elem === 4; }); // use a function that takes the query as second parameter // $query will have the value 4 as you've just passed in $found = $list->search(4, function (int $elem, int $query): bool { return $elem === $query; });","title":"Search for Existence"},{"location":"collection/#find-an-element","text":"While search() only tells you some element is present, if you want to return this element use the find() rsp. findAll() method. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'banana', 'pine', 'banana', 'ananas']); $pine = $fruits->find(function (string $elem): bool { return $elem === 'pine'; }); $bananas = $fruits->findAll(function(string $elem): bool { return $elem === 'banana'; });","title":"Find an Element"},{"location":"collection/#find-an-index","text":"If you are interested in the index of a search, you can use findIndex() . There is also findLastIndex() which searches the list from back to front. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'banana', 'pine', 'banana', 'ananas']); $index = $fruits->findIndex(function (string $elem): bool { return $elem == 'banana'; }); echo $index; // 1 $lastIndex = $fruits->findLastIndex(function (string $elem): bool { return $elem == 'banana'; }); echo $lastIndex; // 3","title":"Find an Index"},{"location":"collection/#reversing","text":"You can swap the order of your elements with reverse() . <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $list = new ArrayList([5, 2, 8, 3, 9, 4, 6, 1, 7, 10]); $reversed = $list->reverse(); print_r($reversed); // [10, 7, 1, 6, 4, 9, 3, 8, 2, 5]","title":"Reversing"},{"location":"collection/#simple-sorting","text":"There is built in support for running sort() : <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $unsorted = new ArrayList([5, 2, 8, 3, 9, 4, 6, 1, 7, 10]); $sorted = $unsorted->sort(); print_r($sorted); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","title":"Simple Sorting"},{"location":"collection/#bring-your-own-comparison","text":"Of course you can use your own comparison to sort a list. In the example below you can see a function in action. The returned value must be an integer: 0 if the first and the second values are equal, -1 if the first is minor of the second, 1 if the first is major of the second. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $unsorted = new ArrayList([5, 2, 8, 3, 9, 4, 6, 1, 7, 10]); $cmp = function (int $a, int $b): int { if ($a == $b) { return 0; } return ($a < $b) ? -1 : 1; }; $sorted = $unsorted->sort($cmp); print_r($sorted); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Or you can bring in any Comparator . So good, there is a ComparableComparator provided by phootwork/lang we can use. <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; use phootwork\\lang\\ComparableComparator; $unsorted = new ArrayList(['x', 'c', 'a', 't', 'm']); $sorted = $unsorted->sort(new ComparableComparator()); print_r($sorted); // ['a', 'c', 'm', 't', 'x']","title":"Bring your own Comparison"},{"location":"collection/#remove","text":"You can remove one or more elements from a collection, via the remove() method: <?php declare(strict_types=1); use phootwork\\collection\\ArrayList; $fruits = new ArrayList(['apple', 'banana', 'pine', 'banana', 'ananas']); $fruits->remove('banana'); $fruits->remove('banana', 'ananas', 'pine'); $fruits->toArray(); // ['apple']","title":"Remove"},{"location":"collection/#more-methods","text":"You can find more ArrayList methods into the api documentation .","title":"More Methods"},{"location":"collection/#set","text":"The Set collection is composed by unique elements. It shares much methods with ArrayList except those which manipulate indexes. When you use a Set collection you really don't care about indexes. As usual, you can create a Set collection by passing an array or an Iterator object to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\Set; $fruits = new Set(['apple', 'pear', 'peach']); Since the collection is composed by unique elements, any duplicates are ignored: <?php declare(strict_types=1); use phootwork\\collection\\Set; $fruits = new Set(['apple', 'pear', 'peach', 'pear', 'banana', 'apple']); $fruits->toArray(); // ['apple', 'pear', 'peach', 'banana']","title":"Set"},{"location":"collection/#addition_1","text":"You can add one or more elements to the Set via the add() method: <?php declare(strict_types=1); use phootwork\\collection\\Set; $fruits = new Set(['apple', 'pear', 'peach']); $fruits->add('banana'); $fruits->add('pineapple', ['kiwi', 'lychee'], 'dorian'); $fruits->toArray(); // ['apple', 'pear', 'peach', 'pineapple', ['kiwi', 'lychee'], 'dorian'] // Since the Set elements are unique, the instruction below doesn't modify the collection $fruits->add('apple', 'peach'); $fruits->toArray(); // ['apple', 'pear', 'peach', 'pineapple', ['kiwi', 'lychee'], 'dorian'] Note Set doesn't have the insert() method.","title":"Addition"},{"location":"collection/#more-methods_1","text":"Many Set methods are shared with other collections: please see the api documentation and the examples above, in ArrayList section of this document.","title":"More Methods"},{"location":"collection/#map_1","text":"A Map is a collection of key-value pairs, where the value can be any type you want, objects included. You can think about Map as an associative array with super-powers. As usual, you can instantiate a new Map object by passing an associative array or an Iterator object to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(['1 wheel' => 'unicycle', '2 wheels' => 'scooter', '4 wheels' => 'car']);","title":"Map"},{"location":"collection/#additions","text":"You can add one element to a Map via the set() method, which requires the key as first argument and the value to add as second argument: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(['1 wheel' => 'unicycle', '2 wheels' => 'scooter', '4 wheels' => 'car']); $vehicles->set('3 wheels', 'sidecar'); You can add more elements via the setAll() method. It expects an associative array or an Iterator of elements to add: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(); $coll = [ '1 wheel' => 'unicycle', '2 wheels' => 'scooter', '3 wheels' => 'sidecar', '4 wheels' => 'car' ]; $vehicles->setAll($coll);","title":"Additions"},{"location":"collection/#getting-the-elements","text":"You can get an element of the collection via the get() method: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(['1 wheel' => 'unicycle', '2 wheels' => 'scooter', '4 wheels' => 'car']); $vehicles->get('4 wheels'); // return 'car' $vehicles->get('6 wheels'); // not found: return null You can also get the key of an element by passing it to the getKey() method: <?php declare(strict_types=1); use phootwork\\collection\\Map; $vehicles = new Map(['1 wheel' => 'unicycle', '2 wheels' => 'scooter', '4 wheels' => 'car']); $vehicles->getKey('scooter'); // return '2 wheels'","title":"Getting the Elements"},{"location":"collection/#more-methods_2","text":"You can find all the other Map methods in the documentation api .","title":"More Methods"},{"location":"collection/#stack","text":"A Stack is a FILO (First In Last Out) collection. As usual you can create a Stack by passing an array, or an Iterator , to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\Stack; $fruits = new Stack(['apple', 'pear', 'peach']); Note When you deal with Stack, the order is important: the constructor pushes the elements to end of the passed array, so when you pop an element it results in the last of the given array.","title":"Stack"},{"location":"collection/#additions_1","text":"You can add one or more elements to the Stack via the push() method: <?php declare(strict_types=1); use phootwork\\collection\\Stack; $fruits = new Stack(['apple', 'pear', 'peach']); $fruits->push('lemon'); $fruits->toArray(); //['apple', 'pear', 'peach', 'lemon'] $fruits->push('pine', 'banana', 'ananas'); $fruits->toArray(); //['apple', 'pear', 'peach', 'lemon', 'pine', 'banana', 'ananas']","title":"Additions"},{"location":"collection/#peek-an-element","text":"The method peek() returns the last inserted element of the collection but it doesn't remove it: <?php declare(strict_types=1); use phootwork\\collection\\Stack; $fruits = new Stack(['apple', 'pear', 'peach', 'pine']); $fruits->size(); // 4 $fruits->peek(); // return 'pine' $fruits->size(); // still 4","title":"Peek an Element"},{"location":"collection/#pop-an-element","text":"Popping an element from a Stack means to retrieve the last inserted element and remove it from the collection: <?php declare(strict_types=1); use phootwork\\collection\\Stack; $fruits = new Stack(['apple', 'pear', 'peach', 'pine']); $fruits->size(); // 4 $fruits->pop(); // return 'pine' $fruits->size(); // 4 $fruits->toArray(); // ['apple', 'pear', 'peach']","title":"Pop an Element"},{"location":"collection/#more-methods_3","text":"You can find all the other Stack methods in the documentation api .","title":"More Methods"},{"location":"collection/#queue","text":"A Queue is a FIFO (First In First Out) collection. As usual, you can create a Queue by passing an array, or an Iterator , to the constructor: <?php declare(strict_types=1); use phootwork\\collection\\Queue; $fruits = new Queue(['apple', 'pear', 'peach']); Note As for the Stack collection, when you deal with Queue, the order is important: the constructor enqueues the elements, so when you poll an element it results in the first of the given array.","title":"Queue"},{"location":"collection/#additions_2","text":"You can add one or more elements to the Queue via the enqueue() method: <?php declare(strict_types=1); use phootwork\\collection\\Queue; $fruits = new Queue(['apple', 'pear', 'peach']); $fruits->enqueue('lemon'); $fruits->toArray(); //['lemon', 'apple', 'pear', 'peach']","title":"Additions"},{"location":"collection/#peek-an-element_1","text":"The peek() method returns the first inserted element of the collection but it doesn't remove it: <?php declare(strict_types=1); use phootwork\\collection\\Queue; $fruits = new Queue(['apple', 'pear', 'peach', 'pine']); $fruits->size(); // 4 $fruits->peek(); // return 'apple' $fruits->size(); // still 4","title":"Peek an Element"},{"location":"collection/#poll-an-element","text":"Polling an element from a Queue means to retrieve the first inserted element from the collection and remove it: <?php declare(strict_types=1); use phootwork\\collection\\Queue; $fruits = new Queue(['apple', 'pear', 'peach', 'pine']); $fruits->size(); // 4 $fruits->poll(); // return 'apple' $fruits->size(); // 3 $fruits->toArray(); // ['pear', 'peach', 'pine']","title":"Poll an Element"},{"location":"collection/#more-methods_4","text":"You can find all the other Queue methods in the documentation api .","title":"More Methods"},{"location":"contributing/","text":"Phootwork Contributing Guide If you're reading this document, it is likely that you have decided to contribute to this project. Therefore, first of all, we want to warmly thank you! The Open Source Software grows and improves thanks to people like you! Contributing to a project is a process with its own rules and we try to explain them along this document. Quick Start for Experienced Programmers Fork, clone and apply your patches. See the directory structure explanation if needed and don't forget to write tests. Run the test suite composer test and fix all red tests. Run static analysis tool (by now, we use Psalm ) composer analytics and fix all errors and issues. Fix the coding standard composer cs-fix . Tip Phootwork also provides the check command to run all the tests and analytics, required for a pull request. Run composer check Requirements To contribute to this project, you should have an good knowledge of PHP (of course) and a basic knowledge of git , Github and the dependency manager composer . First Step: Clone the Project and Install the Dependencies The phootwork project is a collection of single libraries that can be installed separately. Anyway, all the development process takes place in the global repository https://github.com/phootwork/phootwork . So, the first step is to fork the phootwork repository on Github and clone it on your local machine. If you have any doubt, please read https://help.github.com/en/articles/fork-a-repo . Then install the dependencies: composer install Understanding the Directory Structure After cloning and installing the dependencies, you should have a directory structure like the following: \u251c\u2500\u2500 bin \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 collection \u2502 \u251c\u2500\u2500 file \u2502 \u2502 \u2514\u2500\u2500 exception \u2502 \u251c\u2500\u2500 json \u2502 \u251c\u2500\u2500 lang | | \u251c\u2500\u2500 inflector \u2502 \u2502 \u2514\u2500\u2500 parts \u2502 \u251c\u2500\u2500 tokenizer \u2502 \u2514\u2500\u2500 xml \u2502 \u2514\u2500\u2500 exception \u251c\u2500\u2500 tests \u2502 \u251c\u2500\u2500 collection \u2502 \u2502 \u2514\u2500\u2500 fixtures \u2502 \u251c\u2500\u2500 file \u2502 \u251c\u2500\u2500 json \u2502 \u251c\u2500\u2500 lang \u2502 \u2502 \u251c\u2500\u2500 fixtures \u2502 \u2502 \u2514\u2500\u2500 inflector \u2502 \u251c\u2500\u2500 tokenizer \u2502 \u2502 \u2514\u2500\u2500 fixtures \u2502 \u2502 \u2514\u2500\u2500 samples \u2502 \u2514\u2500\u2500 xml \u2502 \u2514\u2500\u2500 fixtures \u2514\u2500\u2500 vendor Into the directory bin we have two scripts: auto_split.sh splits the whole Phootwork repository into the single library packages and build_api.sh generates the api documentation. You usually don't care about them, because they are run by our continuous integration server Travis ci . As usual, into the directory vendor you can find all the libraries Phootwork depends on, both for runtime and development. The directory src contains the source code of our libraries and tests contains the relative tests. Both src and tests have sub-folders which correspond to the single libraries. E.g. you can find the source code of the library https://github.com/phootwork/lang into src/lang folder and the relative tests into tests/lang directory. Running the Test Suite While developing, the test part is very important: if you apply a patch to the existing code, the test suite must run without errors or failures and if you add a new functionality, no one will consider it without tests. Our test tool is PhpUnit and we provide a script to launch it: composer test Since our command runs phpunit binary under the hood, you can pass all phpunit options to it via the -- operator, i.e.: composer test -- --stop-on-failure You can also use phpunit directly: vendor/bin/phpunit Each single library has its own test suite and you can launch it separately. I.e. if you want to run the phootwork/lang test suite: composer test -- --testsuite lang or alternatively: vendor/bin/phpunit --testsuite lang The last two commands can be useful to speed up the tests, if your contribution involves only one library. Phootwork also provides a command to generate a code coverage report in html format, into the coverage/ directory: composer coverage Static Analysis Tool To prevent as many bugs as possible, we use a static analysis tool called Psalm . To launch it, run the following command from the root directory of Phootwork project: composer analytics After its analysis, Psalm outputs errors and issues with its suggestions on how to fix them. Errors are more important and generally more dangerous than issues, anyway you should fix both. Coding Standard Phootwork ships its scripts to easily fix coding standard errors, via php-cs-fixer tool. To fix coding standard errors just run: composer cs-fix and to show the errors without fixing them, run: composer cs If you want to learn more about phootwork code style, see https://github.com/phootwork/php-cs-fixer-config. Icing on the Cake Phootwork provides a script to run all the previous explained commands in a single line: composer check It runs all the tests, analytics and code fixers needed before submitting a pull request.","title":"Contributing"},{"location":"contributing/#phootwork-contributing-guide","text":"If you're reading this document, it is likely that you have decided to contribute to this project. Therefore, first of all, we want to warmly thank you! The Open Source Software grows and improves thanks to people like you! Contributing to a project is a process with its own rules and we try to explain them along this document.","title":"Phootwork Contributing Guide"},{"location":"contributing/#quick-start-for-experienced-programmers","text":"Fork, clone and apply your patches. See the directory structure explanation if needed and don't forget to write tests. Run the test suite composer test and fix all red tests. Run static analysis tool (by now, we use Psalm ) composer analytics and fix all errors and issues. Fix the coding standard composer cs-fix . Tip Phootwork also provides the check command to run all the tests and analytics, required for a pull request. Run composer check","title":"Quick Start for Experienced Programmers"},{"location":"contributing/#requirements","text":"To contribute to this project, you should have an good knowledge of PHP (of course) and a basic knowledge of git , Github and the dependency manager composer .","title":"Requirements"},{"location":"contributing/#first-step-clone-the-project-and-install-the-dependencies","text":"The phootwork project is a collection of single libraries that can be installed separately. Anyway, all the development process takes place in the global repository https://github.com/phootwork/phootwork . So, the first step is to fork the phootwork repository on Github and clone it on your local machine. If you have any doubt, please read https://help.github.com/en/articles/fork-a-repo . Then install the dependencies: composer install","title":"First Step: Clone the Project and Install the Dependencies"},{"location":"contributing/#understanding-the-directory-structure","text":"After cloning and installing the dependencies, you should have a directory structure like the following: \u251c\u2500\u2500 bin \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 collection \u2502 \u251c\u2500\u2500 file \u2502 \u2502 \u2514\u2500\u2500 exception \u2502 \u251c\u2500\u2500 json \u2502 \u251c\u2500\u2500 lang | | \u251c\u2500\u2500 inflector \u2502 \u2502 \u2514\u2500\u2500 parts \u2502 \u251c\u2500\u2500 tokenizer \u2502 \u2514\u2500\u2500 xml \u2502 \u2514\u2500\u2500 exception \u251c\u2500\u2500 tests \u2502 \u251c\u2500\u2500 collection \u2502 \u2502 \u2514\u2500\u2500 fixtures \u2502 \u251c\u2500\u2500 file \u2502 \u251c\u2500\u2500 json \u2502 \u251c\u2500\u2500 lang \u2502 \u2502 \u251c\u2500\u2500 fixtures \u2502 \u2502 \u2514\u2500\u2500 inflector \u2502 \u251c\u2500\u2500 tokenizer \u2502 \u2502 \u2514\u2500\u2500 fixtures \u2502 \u2502 \u2514\u2500\u2500 samples \u2502 \u2514\u2500\u2500 xml \u2502 \u2514\u2500\u2500 fixtures \u2514\u2500\u2500 vendor Into the directory bin we have two scripts: auto_split.sh splits the whole Phootwork repository into the single library packages and build_api.sh generates the api documentation. You usually don't care about them, because they are run by our continuous integration server Travis ci . As usual, into the directory vendor you can find all the libraries Phootwork depends on, both for runtime and development. The directory src contains the source code of our libraries and tests contains the relative tests. Both src and tests have sub-folders which correspond to the single libraries. E.g. you can find the source code of the library https://github.com/phootwork/lang into src/lang folder and the relative tests into tests/lang directory.","title":"Understanding the Directory Structure"},{"location":"contributing/#running-the-test-suite","text":"While developing, the test part is very important: if you apply a patch to the existing code, the test suite must run without errors or failures and if you add a new functionality, no one will consider it without tests. Our test tool is PhpUnit and we provide a script to launch it: composer test Since our command runs phpunit binary under the hood, you can pass all phpunit options to it via the -- operator, i.e.: composer test -- --stop-on-failure You can also use phpunit directly: vendor/bin/phpunit Each single library has its own test suite and you can launch it separately. I.e. if you want to run the phootwork/lang test suite: composer test -- --testsuite lang or alternatively: vendor/bin/phpunit --testsuite lang The last two commands can be useful to speed up the tests, if your contribution involves only one library. Phootwork also provides a command to generate a code coverage report in html format, into the coverage/ directory: composer coverage","title":"Running the Test Suite"},{"location":"contributing/#static-analysis-tool","text":"To prevent as many bugs as possible, we use a static analysis tool called Psalm . To launch it, run the following command from the root directory of Phootwork project: composer analytics After its analysis, Psalm outputs errors and issues with its suggestions on how to fix them. Errors are more important and generally more dangerous than issues, anyway you should fix both.","title":"Static Analysis Tool"},{"location":"contributing/#coding-standard","text":"Phootwork ships its scripts to easily fix coding standard errors, via php-cs-fixer tool. To fix coding standard errors just run: composer cs-fix and to show the errors without fixing them, run: composer cs If you want to learn more about phootwork code style, see https://github.com/phootwork/php-cs-fixer-config.","title":"Coding Standard"},{"location":"contributing/#icing-on-the-cake","text":"Phootwork provides a script to run all the previous explained commands in a single line: composer check It runs all the tests, analytics and code fixers needed before submitting a pull request.","title":"Icing on the Cake"},{"location":"docs_contributing/","text":"Contributing to the Documentation The Phootwork documentation site is written in markdown and built with MkDocs . Branch strategy The documentation repository has two branches: mkdocs contains the markdown documentation. You should work on this branch if you want to contribute and you should submit here your pull requests. master contains the site compiled by Mkdocs. This branch is handled only by our Github Actions bot. No pull request will be merged on it. Clone and Install Fork and clone the documentation repository Install MkDocs Install Cinder theme by running: pip install mkdocs-cinder Install fontawesome-markdown extension by running: pip install https://github.com/bmcorser/fontawesome-markdown/archive/master.zip Markdown flavour MkDocs uses Python-Markdown with some extensions active by default. It supports the standard markdown, markdown-extra and some of the Github-flavoured markdown features. You can find detailed information on https://www.mkdocs.org/user-guide/writing-your-docs/#writing-with-markdown . In Phootwork environment, we active also admonition and fontawesome-markdown . Admonition admonition extension helps to write beautiful notes or warnings or other (see the official documentation) with a syntax like the following: !!! Danger Very dangerous operation! which translates into the following: Danger Very dangerous operation! Fontawesome fontawesome-markdown extension allow to include Fontawesome icons in any part of the documentation, via a simple notation: :icon-type icon: . In example: _I :fas fa-heart: phootwork!_ translates into: I phootwork! .","title":"Documentation Contributing"},{"location":"docs_contributing/#contributing-to-the-documentation","text":"The Phootwork documentation site is written in markdown and built with MkDocs .","title":"Contributing to the Documentation"},{"location":"docs_contributing/#branch-strategy","text":"The documentation repository has two branches: mkdocs contains the markdown documentation. You should work on this branch if you want to contribute and you should submit here your pull requests. master contains the site compiled by Mkdocs. This branch is handled only by our Github Actions bot. No pull request will be merged on it.","title":"Branch strategy"},{"location":"docs_contributing/#clone-and-install","text":"Fork and clone the documentation repository Install MkDocs Install Cinder theme by running: pip install mkdocs-cinder Install fontawesome-markdown extension by running: pip install https://github.com/bmcorser/fontawesome-markdown/archive/master.zip","title":"Clone and Install"},{"location":"docs_contributing/#markdown-flavour","text":"MkDocs uses Python-Markdown with some extensions active by default. It supports the standard markdown, markdown-extra and some of the Github-flavoured markdown features. You can find detailed information on https://www.mkdocs.org/user-guide/writing-your-docs/#writing-with-markdown . In Phootwork environment, we active also admonition and fontawesome-markdown .","title":"Markdown flavour"},{"location":"docs_contributing/#admonition","text":"admonition extension helps to write beautiful notes or warnings or other (see the official documentation) with a syntax like the following: !!! Danger Very dangerous operation! which translates into the following: Danger Very dangerous operation!","title":"Admonition"},{"location":"docs_contributing/#fontawesome","text":"fontawesome-markdown extension allow to include Fontawesome icons in any part of the documentation, via a simple notation: :icon-type icon: . In example: _I :fas fa-heart: phootwork!_ translates into: I phootwork! .","title":"Fontawesome"},{"location":"file/","text":"Phootwork file Photwwork file library for the local filesystem. Provide abstractions to the local file system Inspired by java java.io.File Inspired by eclipse org.eclipse.core.runtime.IPath Installation Install via Composer: composer require phootwork/file Paths Paths contain the location to files or directories. Understand various paths with at this given example: File: /path/to/my/file.ext Directory: /path/to/directory Contains the following paths for file and directory: Name File Path Directory Path Dirname /path/to/my /path/to Filename file.ext directory Extension ext - Pathname /path/to/my/file.ext /path/to/directory Building Paths The Path class helps out with all utilities to handle paths. Let's start with a base path from which we append to a locales directory and config file where we change the extension later on: $base = new Path('/path/to'); $locales = $base->append('locales'); // /path/to/locales $config = $base->append('config.yml'); // /path/to/config.yml $config->getPathname(); // /path/to/config.yml $config->getFilename(); // config.yml $config->getDirname(); // /path/to $config->getExtension(); // yml $config->setExtension('json'); // /path/to/config.json Absolute or Relative? Easy checks whether a path is empty or absolute: $dunnoWhatPathIHaveHere = '...'; // we get this as a return from somewhere else if ($dunnoWhatPathIHaveHere->isEmpty()) { // nothing to see here, go away! } if ($dunnoWhatPathIHaveHere->iAbsolute()) { // also works on windows! } Handling segments Segments are all the parts between the path delimiter / (even windows path are stored as unix path internally). Some convenient methods for them: $p = new Path('this/is/the/path/to/my/file.ext'); $p->segments()->toArray(); // ['this', 'is', 'the', 'path', 'to', 'my', 'file.ext'] $p->segmentCount(); // 7 $p->segment(1); // is $p->lastSegment(); // file.ext $p->upToSegment(3); // this/is/the $p->removeFirstSegments(2); // the/path/to/my/file.ext $p->removeLastSegments(2); // this/is/the/path/to $p->upToSegment(0); // (empty string) Trailing Slash? Very often you need to have a trailing slash (or not). This is ugly to do with given string manipulation functions, this is covered for sure: $p = new Path('/path/to/folder'); $p->hasTrailingSeparator(); // false $p->addTrailingSeparator(); // /path/to/folder/ $p->addTrailingSeparator(); // hah! doesn't add twice here! $p->hasTrailingSeparator(); // true $p->removeTrailingSeparator(); // /path/to/folder $p->hasTrailingSeparator(); // false Whenever you need the path with a trailing slash, call $p->addTrailingSeparator() which works as your \"guarding operator\" and you can be sure, there will be one - and only one - trailing separator add the end of your path. Working with other Paths A quite frequent operation for paths is to work with other paths. For example is one path the parent of another how is one path relative to another one? Instead of having replace and string logic, focus on writing clean and semantic code. $file = new Path('this/is/the/path/to/my/file.ext'); $parent = new Path('this/is/the'); if ($parent->isPrefixOf($file)) { // yup, we are } $file->makeRelativeTo($parent); // path/to/my/file.ext It's sometimes interessting to know how much equal two paths are, here comes matchingFirstSegments() and equals() : $base = new Path('this/is/the/path/to/my/file.ext'); $prefix = new Path('this/is/the'); $anotherPath = new Path('this/is/another/path'); $base->matchingFirstSegments($prefix); // 3 $base->matchingFirstSegments($anotherPath); // 2 $prefix->equals($base); // false $prefix->equals('this/is/the'); // true Stream Support All the above mentioned paths methods work with streams, here is an example: $stream = new Path('file:///Home/Documents'); $stream->isAbsolute(); // true $stream->isStream(); // true Filesystem The phootwork/file package comes with two classes to access the local filesystem that share a unified and convenient API: File Directory For both scenarios, they are instantiated with the pathname or path as argument for the constructor: $directoryPathname = '/path/to/directory' $directory = new Directory($directoryPathname); $filePathname = '/path/to/file.ext'; $file = new File($filePathname); // -- or -- $directoryPath = new Path('/path/to/directory'); $directory = new Directory($directoryPath); $filePath = new Path('/path/to/file.ext'); $file = new File($filePath); Learn more about handling path . Operations Main operations move , copy and delete are supported. Also handy, does a file exist ? $file = new File('hello/world.txt'); $file->exists(); // true $file->move('been/there/done/that'); $file->copy('exactly'); $file->delete(); Important: delete() on directories works recursively! The operations onto each of those instances may vary: For files: create, read and write For directories: create and iterate directories Links A path can point to a link or not independent whether this is a file or directory. Operations will be executed on the link target location. Creating links is not supported (yet ? - submit a PR ;-). Checking whether you are operating on one and where that will be is supported: $dir = new Directory('path/to/portal'); $dir->isLink(); // true $dir->getLinkTarget(); // path/to/original/destination Attributes A file has plenty attributes, such as the owner or the last accessed time. Permissions Permissions are relevant when you are in need changing them in order to make files writable. There are convenient checks to test some of those permissions: isReadable() - to test whether it can be read isWritable() - to test whether it can be written isExecutable() - to test whether it can be executed For more details there is getOwner() and getGroup() to know whom this file belongs to and setOwner() , setGroup() and setMode() to change all of that. Timestamps Timestamps for files are retrievable via getCreatedAt() , getLastAccessedAt() and getModifiedAt() . You can use touch() to change them. Directories Create a Directory Try creating a directory and catch upon afterwards if that plan failed: try { $dir = new Directory('/hello/there'); $dir->make(); } catch (FileException $e) { // oupsi } and delete the directory later on: try { $dir = new Directory('/hello/there'); $dir->delete(); } catch (FileException $e) { // nope, not gonna happen } Important notice: delete() on a directory works recursively (unlink phps rmdir() function). Iterate a Directory For most of the time, you want to iterate over the files within a directory - recursively or not is up to you. Let's have a look at an example: $files = new ArrayList(); $folders = new ArrayList(); $dir = new Directory('path/to/folder'); foreach ($dir as $file) { if ($file->isDot()) { continue; } if ($file->isFile()) { $files->add($file->toFile()); } if ($file->isFolder()) { $folders->add($file->toDirectory()); } } The $file is our own FileDescriptor , that offers the same operations mentioned under Filesystem plus has checks for isDot() , isFile() and isDirectory() . Additionally brings transforms to cast a $file in toFile() and toDirectory() . Files Creating Empty Files To create empty files, just touch() them: $file->touch(); Note touch() can also be used to changes created and lastAcceessed attributes. Reading and Writing Retrieving and putting contents of and to files is straightforward using read() and write($content) methods: $content = $file->read(); $content .= 'addition'; $file->write($content); Testing For testing your implementations, phootwork/file works very nice with mikey179/vfsStream . Use vfsStream to test your own package (so does phootwork/file ). Head over to vfs.bovigo.org for the documentation on how to use vfsStream .","title":"File"},{"location":"file/#phootwork-file","text":"Photwwork file library for the local filesystem. Provide abstractions to the local file system Inspired by java java.io.File Inspired by eclipse org.eclipse.core.runtime.IPath","title":"Phootwork file"},{"location":"file/#installation","text":"Install via Composer: composer require phootwork/file","title":"Installation"},{"location":"file/#paths","text":"Paths contain the location to files or directories. Understand various paths with at this given example: File: /path/to/my/file.ext Directory: /path/to/directory Contains the following paths for file and directory: Name File Path Directory Path Dirname /path/to/my /path/to Filename file.ext directory Extension ext - Pathname /path/to/my/file.ext /path/to/directory","title":"Paths"},{"location":"file/#building-paths","text":"The Path class helps out with all utilities to handle paths. Let's start with a base path from which we append to a locales directory and config file where we change the extension later on: $base = new Path('/path/to'); $locales = $base->append('locales'); // /path/to/locales $config = $base->append('config.yml'); // /path/to/config.yml $config->getPathname(); // /path/to/config.yml $config->getFilename(); // config.yml $config->getDirname(); // /path/to $config->getExtension(); // yml $config->setExtension('json'); // /path/to/config.json","title":"Building Paths"},{"location":"file/#absolute-or-relative","text":"Easy checks whether a path is empty or absolute: $dunnoWhatPathIHaveHere = '...'; // we get this as a return from somewhere else if ($dunnoWhatPathIHaveHere->isEmpty()) { // nothing to see here, go away! } if ($dunnoWhatPathIHaveHere->iAbsolute()) { // also works on windows! }","title":"Absolute or Relative?"},{"location":"file/#handling-segments","text":"Segments are all the parts between the path delimiter / (even windows path are stored as unix path internally). Some convenient methods for them: $p = new Path('this/is/the/path/to/my/file.ext'); $p->segments()->toArray(); // ['this', 'is', 'the', 'path', 'to', 'my', 'file.ext'] $p->segmentCount(); // 7 $p->segment(1); // is $p->lastSegment(); // file.ext $p->upToSegment(3); // this/is/the $p->removeFirstSegments(2); // the/path/to/my/file.ext $p->removeLastSegments(2); // this/is/the/path/to $p->upToSegment(0); // (empty string)","title":"Handling segments"},{"location":"file/#trailing-slash","text":"Very often you need to have a trailing slash (or not). This is ugly to do with given string manipulation functions, this is covered for sure: $p = new Path('/path/to/folder'); $p->hasTrailingSeparator(); // false $p->addTrailingSeparator(); // /path/to/folder/ $p->addTrailingSeparator(); // hah! doesn't add twice here! $p->hasTrailingSeparator(); // true $p->removeTrailingSeparator(); // /path/to/folder $p->hasTrailingSeparator(); // false Whenever you need the path with a trailing slash, call $p->addTrailingSeparator() which works as your \"guarding operator\" and you can be sure, there will be one - and only one - trailing separator add the end of your path.","title":"Trailing Slash?"},{"location":"file/#working-with-other-paths","text":"A quite frequent operation for paths is to work with other paths. For example is one path the parent of another how is one path relative to another one? Instead of having replace and string logic, focus on writing clean and semantic code. $file = new Path('this/is/the/path/to/my/file.ext'); $parent = new Path('this/is/the'); if ($parent->isPrefixOf($file)) { // yup, we are } $file->makeRelativeTo($parent); // path/to/my/file.ext It's sometimes interessting to know how much equal two paths are, here comes matchingFirstSegments() and equals() : $base = new Path('this/is/the/path/to/my/file.ext'); $prefix = new Path('this/is/the'); $anotherPath = new Path('this/is/another/path'); $base->matchingFirstSegments($prefix); // 3 $base->matchingFirstSegments($anotherPath); // 2 $prefix->equals($base); // false $prefix->equals('this/is/the'); // true","title":"Working with other Paths"},{"location":"file/#stream-support","text":"All the above mentioned paths methods work with streams, here is an example: $stream = new Path('file:///Home/Documents'); $stream->isAbsolute(); // true $stream->isStream(); // true","title":"Stream Support"},{"location":"file/#filesystem","text":"The phootwork/file package comes with two classes to access the local filesystem that share a unified and convenient API: File Directory For both scenarios, they are instantiated with the pathname or path as argument for the constructor: $directoryPathname = '/path/to/directory' $directory = new Directory($directoryPathname); $filePathname = '/path/to/file.ext'; $file = new File($filePathname); // -- or -- $directoryPath = new Path('/path/to/directory'); $directory = new Directory($directoryPath); $filePath = new Path('/path/to/file.ext'); $file = new File($filePath); Learn more about handling path .","title":"Filesystem"},{"location":"file/#operations","text":"Main operations move , copy and delete are supported. Also handy, does a file exist ? $file = new File('hello/world.txt'); $file->exists(); // true $file->move('been/there/done/that'); $file->copy('exactly'); $file->delete(); Important: delete() on directories works recursively! The operations onto each of those instances may vary: For files: create, read and write For directories: create and iterate directories","title":"Operations"},{"location":"file/#links","text":"A path can point to a link or not independent whether this is a file or directory. Operations will be executed on the link target location. Creating links is not supported (yet ? - submit a PR ;-). Checking whether you are operating on one and where that will be is supported: $dir = new Directory('path/to/portal'); $dir->isLink(); // true $dir->getLinkTarget(); // path/to/original/destination","title":"Links"},{"location":"file/#attributes","text":"A file has plenty attributes, such as the owner or the last accessed time.","title":"Attributes"},{"location":"file/#permissions","text":"Permissions are relevant when you are in need changing them in order to make files writable. There are convenient checks to test some of those permissions: isReadable() - to test whether it can be read isWritable() - to test whether it can be written isExecutable() - to test whether it can be executed For more details there is getOwner() and getGroup() to know whom this file belongs to and setOwner() , setGroup() and setMode() to change all of that.","title":"Permissions"},{"location":"file/#timestamps","text":"Timestamps for files are retrievable via getCreatedAt() , getLastAccessedAt() and getModifiedAt() . You can use touch() to change them.","title":"Timestamps"},{"location":"file/#directories","text":"","title":"Directories"},{"location":"file/#create-a-directory","text":"Try creating a directory and catch upon afterwards if that plan failed: try { $dir = new Directory('/hello/there'); $dir->make(); } catch (FileException $e) { // oupsi } and delete the directory later on: try { $dir = new Directory('/hello/there'); $dir->delete(); } catch (FileException $e) { // nope, not gonna happen } Important notice: delete() on a directory works recursively (unlink phps rmdir() function).","title":"Create a Directory"},{"location":"file/#iterate-a-directory","text":"For most of the time, you want to iterate over the files within a directory - recursively or not is up to you. Let's have a look at an example: $files = new ArrayList(); $folders = new ArrayList(); $dir = new Directory('path/to/folder'); foreach ($dir as $file) { if ($file->isDot()) { continue; } if ($file->isFile()) { $files->add($file->toFile()); } if ($file->isFolder()) { $folders->add($file->toDirectory()); } } The $file is our own FileDescriptor , that offers the same operations mentioned under Filesystem plus has checks for isDot() , isFile() and isDirectory() . Additionally brings transforms to cast a $file in toFile() and toDirectory() .","title":"Iterate a Directory"},{"location":"file/#files","text":"","title":"Files"},{"location":"file/#creating-empty-files","text":"To create empty files, just touch() them: $file->touch(); Note touch() can also be used to changes created and lastAcceessed attributes.","title":"Creating Empty Files"},{"location":"file/#reading-and-writing","text":"Retrieving and putting contents of and to files is straightforward using read() and write($content) methods: $content = $file->read(); $content .= 'addition'; $file->write($content);","title":"Reading and Writing"},{"location":"file/#testing","text":"For testing your implementations, phootwork/file works very nice with mikey179/vfsStream . Use vfsStream to test your own package (so does phootwork/file ). Head over to vfs.bovigo.org for the documentation on how to use vfsStream .","title":"Testing"},{"location":"json/","text":"Phoootwork collection Phootwork json library. Wrap native PHP functions with classes Provide solid error handling with exceptions Installation Installation via composer: composer require phootwork/json Decode The Json::decode() works almost similarly to php's json_decode() except it always returns an array instead of an object. Synopsis array Json::decode(string $json [, int $options = 0 [, int $depth = 512]]) Simple Decoding Decoding is straight forward: <?php declare(strict_types=1); use phootwork\\json\\Json; $json = '...'; $array = Json::decode($json); Note : Unlike php, this library returns decoded JSON as array! Decode to Collection The json package works in harmony with Collections . You can decode json into any collection easily. <?php declare(strict_types=1); use phootwork\\json\\Json; $json = '...'; $array = Json::toCollection($json); The collection parser will detect what kind of collection type ( Map or ArrayList ) the provided json is and will return the matching type of collection. If you know what kind of collection to expect you can call Json::toMap() or Json::toList() directly. Encode The Json::encode() function works almost similarly to php's json_encode() , except there is proper error handling built in. Synopsis string Json::encode(mixed $data [, int $options = 0 [, int $depth = 512]]) Simple Encoding Encoding data into json is done straight forward: <?php declare(strict_types=1); use phootwork\\json\\Json; $data = [...]; $json = Json::encode($data); Encode with Options You can also pass options as second parameter: <?php declare(strict_types=1); use phootwork\\json\\Json; $data = [...]; $json = Json::encode($data, Json::PRETTY_PRINT | Json::UNESCAPED_SLASHES); Error Handling Error handling with native php functions is a bit ... well... \"old\". For that reason every call to Json::* will throw an exception. Let's see an example for that: <?php declare(strict_types=1); use phootwork\\json\\Json; use phootwork\\json\\JsonException; try { $json = '...'; $array = Json::decode($json); } catch (JsonException $e) { echo $e->getMessage(); }","title":"Json"},{"location":"json/#phoootwork-collection","text":"Phootwork json library. Wrap native PHP functions with classes Provide solid error handling with exceptions","title":"Phoootwork collection"},{"location":"json/#installation","text":"Installation via composer: composer require phootwork/json","title":"Installation"},{"location":"json/#decode","text":"The Json::decode() works almost similarly to php's json_decode() except it always returns an array instead of an object.","title":"Decode"},{"location":"json/#synopsis","text":"array Json::decode(string $json [, int $options = 0 [, int $depth = 512]])","title":"Synopsis"},{"location":"json/#simple-decoding","text":"Decoding is straight forward: <?php declare(strict_types=1); use phootwork\\json\\Json; $json = '...'; $array = Json::decode($json); Note : Unlike php, this library returns decoded JSON as array!","title":"Simple Decoding"},{"location":"json/#decode-to-collection","text":"The json package works in harmony with Collections . You can decode json into any collection easily. <?php declare(strict_types=1); use phootwork\\json\\Json; $json = '...'; $array = Json::toCollection($json); The collection parser will detect what kind of collection type ( Map or ArrayList ) the provided json is and will return the matching type of collection. If you know what kind of collection to expect you can call Json::toMap() or Json::toList() directly.","title":"Decode to Collection"},{"location":"json/#encode","text":"The Json::encode() function works almost similarly to php's json_encode() , except there is proper error handling built in.","title":"Encode"},{"location":"json/#synopsis_1","text":"string Json::encode(mixed $data [, int $options = 0 [, int $depth = 512]])","title":"Synopsis"},{"location":"json/#simple-encoding","text":"Encoding data into json is done straight forward: <?php declare(strict_types=1); use phootwork\\json\\Json; $data = [...]; $json = Json::encode($data);","title":"Simple Encoding"},{"location":"json/#encode-with-options","text":"You can also pass options as second parameter: <?php declare(strict_types=1); use phootwork\\json\\Json; $data = [...]; $json = Json::encode($data, Json::PRETTY_PRINT | Json::UNESCAPED_SLASHES);","title":"Encode with Options"},{"location":"json/#error-handling","text":"Error handling with native php functions is a bit ... well... \"old\". For that reason every call to Json::* will throw an exception. Let's see an example for that: <?php declare(strict_types=1); use phootwork\\json\\Json; use phootwork\\json\\JsonException; try { $json = '...'; $array = Json::decode($json); } catch (JsonException $e) { echo $e->getMessage(); }","title":"Error Handling"},{"location":"lang/","text":"Phootwork lang Phootwork lang contains missing PHP language constructs Provide common but missing php classes Objects for native php constructs Consistent API Inspired by java.lang , java.util and Stringy Arrays are key data structures for both map and list like types in php. Installation Installation via composer: composer require phootwork/lang Array Arrays are key data structures for both map and list like types in php. Arrayable Getting an array from an object is not easy to know. That's why there is an Arrayable interface which has only one method: toArray() and helps to be put on objects that will return an array. Use it for type-hinting or check the instance of an object whether is arrayable. ArrayObject An ArrayObject is a wrapper around a native php array but provides consistent methods instead of weird functions and parameter order that are hard to read in your code. Alternatively you can use the Collection package. Comparison Comparison in php is mainly supported on a function level, e.g. sort() (and other array sorting functions). Also php provides usort() to pass in your own comparison code, there is no such thing on a class level. Comparable Implement the Comparable interface on those objects you want to compare with others. You can now compare your object to another one: <?php declare(strict_types=1); use phootwork\\lang\\Comparable; class MeasurementPoint implements Comparable { // ... public function compareTo($comparison) { // comparison logic here } } $p1 = new MeasurementPoint(); $p2 = new MeasurementPoint(); $p2->compareTo($p1); Comparator A Comparator is somebody who compares two values with each other. Use it to compare your objects. <?php declare(strict_types=1); use phootwork\\lang\\Comparator; class MeasurementComparator implements Comparator { public function compare($a, $b) { return $a->compareTo($b); } } $p1 = new MeasurementPoint(); $p2 = new MeasurementPoint(); $comparator = new MeasurementComparator(); $comparator->compare($a, $b); ComparableComparator The ComparableComparator contains the same functionality as the MeasurementComparator above. If you don't have a comparator at hand and need one, the ComparableComparator is there for you. String For string manipulation php offers a lot of functions with inconsistent naming scheme and parameter ordering. Here is the Text (since string is a reserved word in php7) class to clear this mess. Instantiation Instantiation can happen in two ways. 1) Regular way with the new keyword: <?php declare(strict_types=1); use phootwork\\lang\\Text; $str = new Text('my string'); 2) Using the static create method: <?php declare(strict_types=1); use phootwork\\lang\\Text; $str = Text::create('my string'); which is mostly helpful in one-line code (such as if statements). Method Chaining Method chaining is possible with the Text class: <?php declare(strict_types=1); use phootwork\\lang\\Text; $str = new Text('MyFunNyStrIng'); $str->lower()->upperFirst(); // Myfunnystring (see also Text::capitalize()) Examples Some examples where the Text class really shines: 1) In if statements: <?php declare(strict_types=1); use phootwork\\lang\\Text; if (Text::create($str)->startsWith('hello')) { // ... }","title":"Lang"},{"location":"lang/#phootwork-lang","text":"Phootwork lang contains missing PHP language constructs Provide common but missing php classes Objects for native php constructs Consistent API Inspired by java.lang , java.util and Stringy Arrays are key data structures for both map and list like types in php.","title":"Phootwork lang"},{"location":"lang/#installation","text":"Installation via composer: composer require phootwork/lang","title":"Installation"},{"location":"lang/#array","text":"Arrays are key data structures for both map and list like types in php.","title":"Array"},{"location":"lang/#arrayable","text":"Getting an array from an object is not easy to know. That's why there is an Arrayable interface which has only one method: toArray() and helps to be put on objects that will return an array. Use it for type-hinting or check the instance of an object whether is arrayable.","title":"Arrayable"},{"location":"lang/#arrayobject","text":"An ArrayObject is a wrapper around a native php array but provides consistent methods instead of weird functions and parameter order that are hard to read in your code. Alternatively you can use the Collection package.","title":"ArrayObject"},{"location":"lang/#comparison","text":"Comparison in php is mainly supported on a function level, e.g. sort() (and other array sorting functions). Also php provides usort() to pass in your own comparison code, there is no such thing on a class level.","title":"Comparison"},{"location":"lang/#comparable","text":"Implement the Comparable interface on those objects you want to compare with others. You can now compare your object to another one: <?php declare(strict_types=1); use phootwork\\lang\\Comparable; class MeasurementPoint implements Comparable { // ... public function compareTo($comparison) { // comparison logic here } } $p1 = new MeasurementPoint(); $p2 = new MeasurementPoint(); $p2->compareTo($p1);","title":"Comparable"},{"location":"lang/#comparator","text":"A Comparator is somebody who compares two values with each other. Use it to compare your objects. <?php declare(strict_types=1); use phootwork\\lang\\Comparator; class MeasurementComparator implements Comparator { public function compare($a, $b) { return $a->compareTo($b); } } $p1 = new MeasurementPoint(); $p2 = new MeasurementPoint(); $comparator = new MeasurementComparator(); $comparator->compare($a, $b);","title":"Comparator"},{"location":"lang/#comparablecomparator","text":"The ComparableComparator contains the same functionality as the MeasurementComparator above. If you don't have a comparator at hand and need one, the ComparableComparator is there for you.","title":"ComparableComparator"},{"location":"lang/#string","text":"For string manipulation php offers a lot of functions with inconsistent naming scheme and parameter ordering. Here is the Text (since string is a reserved word in php7) class to clear this mess.","title":"String"},{"location":"lang/#instantiation","text":"Instantiation can happen in two ways. 1) Regular way with the new keyword: <?php declare(strict_types=1); use phootwork\\lang\\Text; $str = new Text('my string'); 2) Using the static create method: <?php declare(strict_types=1); use phootwork\\lang\\Text; $str = Text::create('my string'); which is mostly helpful in one-line code (such as if statements).","title":"Instantiation"},{"location":"lang/#method-chaining","text":"Method chaining is possible with the Text class: <?php declare(strict_types=1); use phootwork\\lang\\Text; $str = new Text('MyFunNyStrIng'); $str->lower()->upperFirst(); // Myfunnystring (see also Text::capitalize())","title":"Method Chaining"},{"location":"lang/#examples","text":"Some examples where the Text class really shines: 1) In if statements: <?php declare(strict_types=1); use phootwork\\lang\\Text; if (Text::create($str)->startsWith('hello')) { // ... }","title":"Examples"},{"location":"license/","text":"License Phootwork libraries are released under the MIT License . The following disclaimer is shipped with all the libraries into the LICENSE file. License disclaimer The MIT License (MIT) Copyright (c) 2015 - 2019 Thomas Gossmann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"Phootwork libraries are released under the MIT License . The following disclaimer is shipped with all the libraries into the LICENSE file.","title":"License"},{"location":"license/#license-disclaimer","text":"The MIT License (MIT) Copyright (c) 2015 - 2019 Thomas Gossmann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License disclaimer"},{"location":"tokenizer/","text":"Work in progress...","title":"Tokenizer"},{"location":"tokenizer/#work-in-progress","text":"","title":"Work in progress..."},{"location":"xml/","text":"Work in progress...","title":"Xml"},{"location":"xml/#work-in-progress","text":"","title":"Work in progress..."}]}